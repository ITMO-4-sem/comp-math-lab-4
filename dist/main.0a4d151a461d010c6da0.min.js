(()=>{"use strict";class t{isRateValid(t){return!isNaN(t)&&isFinite(t)}areRatesValid(...t){let e=!0;for(let a=0;a<t.length&&(e=e&&this.isRateValid(t[a]),e);a++);return e}}class e extends t{approximate(t){let e=0,a=0,i=0,r=0,n=0;const s=t.getXValues(),o=t.getYValues(),l=s.length;for(let t=0;t<l;t++){const l=s[t],c=o[t];e+=l,a+=l*l,i+=c,r+=c*c,n+=l*c}const c=a*l-e*e,u=(n*l-e*i)/c,h=(a*i-e*n)/c,p=(l*n-e*i)/Math.sqrt((l*a-e*e)*(l*r-i*i));if(!this.areRatesValid(u,h,p))throw new Error("Can't perform calculations. Division by zero.");return{a:u,b:h,ext:p}}}class a extends t{approximate(t){let e=0,a=0,i=0,r=0;const n=t.getXValues(),s=t.getYValues(),o=n.length;for(let t=0;t<o;t++){const o=n[t],l=s[t];l<=0||(e+=o*Math.log(l),i+=o,a+=Math.log(l),r+=o*o)}const l=(o*e-i*a)/(o*r-i*i),c=1/o*a-l/o*i;if(!this.areRatesValid(c,l))throw new Error("Can't perform calculations. Division by zero or other calculation error. Please, enter different data.");return{a:c,b:l}}}class i extends t{approximate(t){let e=0,a=0,i=0,r=0;const n=t.getXValues(),s=t.getYValues(),o=n.length;for(let t=0;t<o;t++){const o=n[t],l=s[t];o<=0||(e+=l*Math.log(o),a+=Math.log(o),i+=l,r+=Math.log(o)*Math.log(o))}const l=(o*e-a*i)/(o*r-a*a),c=1/o*i-l/o*a;if(!this.areRatesValid(c,l))throw new Error("Can't perform calculations. Division by zero.");return{a:c,b:l}}}class r extends t{approximate(t){let e=0,a=0,i=0,r=0;const n=t.getXValues(),s=t.getYValues(),o=n.length;for(let t=0;t<o;t++){const o=n[t],l=s[t];o<=0||l<=0||(e+=Math.log(o)*Math.log(l),a+=Math.log(o),i+=Math.log(l),r+=Math.log(o)*Math.log(o))}const l=(o*e-a*i)/(o*r-a*a),c=Math.exp(1/o*i-l/o*a);if(!this.areRatesValid(c,l))throw new Error("Can't perform calculations. Division by zero.");return{a:c,b:l}}}class n{constructor(t,e,a){this.a=t,this.b=e,this.c=a}}class s{constructor(...t){const e=t.length;if(e<2)throw new Error("The matrix size must be at least 2.");for(const a of t)if(a.length!==e+1)throw new Error(`'Invalid number of numbers in the matrix row. Must be: ${e}, got: ${a.length}. Row: \n                    \n ${a}`);this.matrix=t,this.matrixSize=e}getColumn(t){if(t>this.matrix[0].length-1)throw new Error("Column number must not be greater the number of columns in the matrix minus one.");const e=new Array;for(let a=0;a<this.matrixSize;a++)e.push(this.matrix[a][t]);return e}getLastColumn(){return this.getColumn(this.matrixSize)}setColumn(t,e){if(e>this.matrix[0].length-1)throw new Error("Column index can't be more than number of columns.");if(t.length!=this.matrix.length)throw new Error("Column length must be the same as the matrix's ones.");for(let a=0;a<t.length;a++)this.matrix[a][e]=t[a]}clone(){const t=new Array;for(const e of this.matrix){const a=new Array;for(const t of e)a.push(t);t.push(a)}return new s(...t)}getMatrix(){return this.matrix}getMatrixSize(){return this.matrixSize}}class o extends t{approximate(t){let e=0,a=0,i=0,r=0,o=0,l=0,c=0;const u=t.getXValues(),h=t.getYValues(),p=u.length;for(let t=0;t<p;t++){const n=u[t],s=h[t];e+=n,a+=n*n,i+=n*n*n,r+=n*n*n*n,o+=s,l+=n*s,c+=n*n*s}const m=new s(new Array(p,e,a,o),new Array(e,a,i,l),new Array(a,i,r,c)),x=class{static solve(t){if(3!=t.getMatrixSize())throw new Error("Sorry, I'm too dull to solve any matrix containing not 3 variables.");const e=t.getLastColumn();let a=t.clone();const i=this.findDeterminant(a);a.setColumn(e,0);const r=this.findDeterminant(a);a=t.clone(),a.setColumn(e,1);const s=this.findDeterminant(a);a=t.clone(),a.setColumn(e,2);const o=this.findDeterminant(a);return new n(r/i,s/i,o/i)}static findDeterminant(t){const e=t.getMatrix();return e[0][0]*e[1][1]*e[2][2]+e[0][1]*e[1][2]*e[2][0]+e[0][2]*e[1][0]*e[2][1]-e[0][2]*e[1][1]*e[2][0]-e[0][1]*e[1][0]*e[2][2]-e[0][0]*e[1][2]*e[2][1]}}.solve(m),g=x.c,d=x.b,w=x.a;if(!this.areRatesValid(g,d,w))throw new Error("Can't perform calculations. Division by zero.");return{a:g,b:d,ext:w}}}class l{constructor(t,e){this.a=t,this.b=e}}class c extends l{calc(t){return Math.exp(this.a+this.b*t)}}class u extends l{calc(t){return this.a*t+this.b}}class h extends l{calc(t){return this.a+this.b*Math.log(t)}}class p extends l{calc(t){return this.a*Math.pow(t,this.b)}}class m extends l{constructor(t,e,a){super(t,e),this.c=a}calc(t){return this.a*t*t+this.b*t+this.c}}const x=new e,g=new class{constructor(t,e){if(t.length!=e.length)throw new Error("xValues and yValues rows must be of the same length.");this.xValues=t,this.yValues=e}size(){return this.xValues.length}getXValues(){return this.xValues}getYValues(){return this.yValues}}(new Array(1.1,2.3,3.7,4.5,5.4,6.8,7.5),new Array(2.73,5.12,7.74,8.91,10.59,12.75,13.43)),d=(x.approximate(g),(new class{do(t){const n=t.size(),s=t.getYValues(),l=t.getXValues(),x=(new a).approximate(t),g=new c(x.a,x.b),d=this.prepareApproxFuncYValues(l,g),w=this.calcDeviationMeasure(s,d),b=this.calcStandardDeviation(w,n),f=this.calcApproximationFunctionReliability(w,d,n),V=(new e).approximate(t),y=new u(V.a,V.b),M=this.prepareApproxFuncYValues(l,y),v=this.calcDeviationMeasure(s,M),D=this.calcStandardDeviation(v,n),R=this.calcApproximationFunctionReliability(v,M,n),A=(new i).approximate(t),F=new h(A.a,A.b),C=this.prepareApproxFuncYValues(l,F),z=this.calcDeviationMeasure(s,C),S=this.calcStandardDeviation(z,n),Y=this.calcApproximationFunctionReliability(z,C,n),E=(new r).approximate(t),X=new p(E.a,E.b),q=this.prepareApproxFuncYValues(l,X),$=this.calcDeviationMeasure(s,q),I=this.calcStandardDeviation($,n),L=this.calcApproximationFunctionReliability(I,q,n),N=(new o).approximate(t),P=new m(N.a,N.b,N.ext),T=this.prepareApproxFuncYValues(l,P),j=this.calcDeviationMeasure(s,T);return{linearFunction:{approxResult:V,yValues:M,deviationMeasure:z,standardDeviation:D,approximationReliability:R},logarithmicFunction:{approxResult:A,yValues:C,deviationMeasure:z,standardDeviation:S,approximationReliability:Y},powerFunction:{approxResult:E,yValues:q,deviationMeasure:$,standardDeviation:I,approximationReliability:L},quadraticFunction:{approxResult:N,yValues:T,deviationMeasure:j,standardDeviation:this.calcStandardDeviation(j,n),approximationReliability:this.calcApproximationFunctionReliability(j,T,n)},exponentialFunction:{approxResult:x,yValues:d,deviationMeasure:w,standardDeviation:b,approximationReliability:f}}}prepareApproxFuncYValues(t,e){const a=new Array;for(let i=0;i<t.length;i++)a.push(e.calc(t[i]));return a}calcDeviationMeasure(t,e){let a=0;for(let i=0;i<t.length;i++)a+=Math.pow(e[i]-t[i],2);return a}calcStandardDeviation(t,e){return Math.sqrt(t/e)}calcApproximationFunctionReliability(t,e,a){let i=0,r=0;for(let t=0;t<e.length;t++){const a=e[t];i+=a,r+=a*a}return 1-t/(r-1/a*i*i)}}).do(g));console.log("------ result ------"),console.log(d)})();